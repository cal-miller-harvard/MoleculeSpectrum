var documenterSearchIndex = {"docs":
[{"location":"api/#MoleculeSpectrum.jl-API-Documentation","page":"API Documentation","title":"MoleculeSpectrum.jl API Documentation","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"    CurrentModule = MoleculeSpectrum\r\n    DocTestSetup  = quote\r\n        using MoleculeSpectrum\r\n    end","category":"page"},{"location":"api/#Contents","page":"API Documentation","title":"Contents","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"    Pages = [\"api.md\"]\r\n    Depth = 4","category":"page"},{"location":"api/#Molecular-Parameters","page":"API Documentation","title":"Molecular Parameters","text":"","category":"section"},{"location":"api/#Molecular-Parameters-2","page":"API Documentation","title":"Molecular Parameters","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"MolecularParameters\r\nKRb_Parameters_Neyenhuis\r\nKRb_Parameters_Ospelkaus\r\nDEFAULT_MOLECULAR_PARAMETERS\r\nTOY_MOLECULE_PARAMETERS","category":"page"},{"location":"api/#MoleculeSpectrum.MolecularParameters","page":"API Documentation","title":"MoleculeSpectrum.MolecularParameters","text":"struct MolecularParameters\n    \"Permanent dipole moment (Debye)\"\n    dₚ::Float64\n    \"Rotational constant (MHz)\"\n    Bᵣ::Float64\n    \"Nuclear angular momenta\"\n    I::SVector{2,HalfInt}\n    \"Zeeman parameters\"\n    zeeman::ZeemanParameters\n    \"Nuclear Parameters\"\n    nuclear::NuclearParameters\n    \"Molecular polarizability at the trapping wavelength\"\n    α::Polarizability\nend\n\nContains the coupling constants for the molecular Hamiltonian and the nuclear angular momenta (needed to  construct the basis states).\n\n\n\n\n\n","category":"type"},{"location":"api/#MoleculeSpectrum.KRb_Parameters_Neyenhuis","page":"API Documentation","title":"MoleculeSpectrum.KRb_Parameters_Neyenhuis","text":"KRb_Parameters_Neyenhuis = MolecularParameters(\n    0.574,\n    1113.9514,\n    [HalfInt(4), HalfInt(3 / 2)],\n    KRb_Zeeman,\n    KRb_Nuclear_Neyenhuis,\n    KRb_Polarizability,\n)\n\nMolecularParameters with experimental values from Neyenhuis et al., PRL 109, 230403 (2012)\n\n\n\n\n\n","category":"constant"},{"location":"api/#MoleculeSpectrum.KRb_Parameters_Ospelkaus","page":"API Documentation","title":"MoleculeSpectrum.KRb_Parameters_Ospelkaus","text":"KRb_Parameters_Ospelkaus = MolecularParameters(\n    0.574,\n    1113.950,\n    [HalfInt(4), HalfInt(3 / 2)],\n    KRb_Zeeman,\n    KRb_Nuclear_Ospelkaus,\n    KRb_Polarizability,\n)\n\nMolecularParameters with experimental values from Ospelkaus et al., PRL 104, 030402 (2010)\n\n\n\n\n\n","category":"constant"},{"location":"api/#MoleculeSpectrum.DEFAULT_MOLECULAR_PARAMETERS","page":"API Documentation","title":"MoleculeSpectrum.DEFAULT_MOLECULAR_PARAMETERS","text":"DEFAULT_MOLECULAR_PARAMETERS\n\nDefault molecular parameters; alias for KRb_Parameters_Neyenhuis\n\n\n\n\n\n","category":"constant"},{"location":"api/#MoleculeSpectrum.TOY_MOLECULE_PARAMETERS","page":"API Documentation","title":"MoleculeSpectrum.TOY_MOLECULE_PARAMETERS","text":"TOY_MOLECULE_PARAMETERS\n\nToy model values with dipole = 1 D, no hyperfine structure, etc. Intended for testing.\n\nNote that the formulas break down for I = 0, which is why we use I = 1 here.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Polarizability-Parameters","page":"API Documentation","title":"Polarizability Parameters","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Polarizability\r\nKRb_Polarizability","category":"page"},{"location":"api/#MoleculeSpectrum.Polarizability","page":"API Documentation","title":"MoleculeSpectrum.Polarizability","text":"struct Polarizability\n    \"Parallel ac polarizability (MHz / (W / cm^2))\"\n    α_par::Float64\n    \"Perpendicular ac polarizability (MHz / (W / cm^2))\"\n    α_perp::Float64\nend\n\nContains the parallel and perpendicular ac polarizabilities at a particular optical wavelength λ.\n\nSo far, it is assumed that λ is far-detuned from any electronic transitions, such that the polarizability does not depend on rotational state N.\n\n\n\n\n\n","category":"type"},{"location":"api/#MoleculeSpectrum.KRb_Polarizability","page":"API Documentation","title":"MoleculeSpectrum.KRb_Polarizability","text":"KRb_Polarizability = Polarizability(10.0e-5, 3.3e-5)\n\nPolarizability with experimental values from Neyenhuis et al., PRL 109, 230403 (2012)\n\n\n\n\n\n","category":"constant"},{"location":"api/#Zeeman-Parameters","page":"API Documentation","title":"Zeeman Parameters","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"ZeemanParameters\r\nKRb_Zeeman","category":"page"},{"location":"api/#MoleculeSpectrum.ZeemanParameters","page":"API Documentation","title":"MoleculeSpectrum.ZeemanParameters","text":"struct ZeemanParameters\n    \"Rotational g factor\"\n    gᵣ::Float64\n    \"Nuclear g factor\"\n    gᵢ::SVector{2,Float64}\n    \"Nuclear shielding factor\"\n    σᵢ::SVector{2,Float64}\nend\n\nContains the g-factors and nuclear shielding factors for computing Zeeman shifts.\n\n\n\n\n\n","category":"type"},{"location":"api/#MoleculeSpectrum.KRb_Zeeman","page":"API Documentation","title":"MoleculeSpectrum.KRb_Zeeman","text":"KRb_Zeeman = ZeemanParameters(0.014, [-0.324, 1.834], [1321e-6, 3469e-6])\n\nZeemanParameters with theoretical values from Aldegunde et al., PRA 78, 033434 (2008)\n\n\n\n\n\n","category":"constant"},{"location":"api/#Nuclear-Parameters","page":"API Documentation","title":"Nuclear Parameters","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"NuclearParameters\r\nKRb_Nuclear_Neyenhuis\r\nKRb_Nuclear_Ospelkaus","category":"page"},{"location":"api/#MoleculeSpectrum.NuclearParameters","page":"API Documentation","title":"MoleculeSpectrum.NuclearParameters","text":"struct NuclearParameters\n    \"Nuclear electric quadrupole (MHz)\"\n    eqQᵢ::SVector{2,Float64}\n    \"Nuclear spin-rotation interaction (MHz)\"\n    cᵢ::SVector{2,Float64}\n    \"Nuclear spin-spin scalar interaction (MHz)\"\n    c₄::Float64\nend\n\nContains the nuclear electric quadrupole moments, nuclear spin-rotation couplings, and nuclear spin-spin coupling for calculating the hyperfine Hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"api/#MoleculeSpectrum.KRb_Nuclear_Neyenhuis","page":"API Documentation","title":"MoleculeSpectrum.KRb_Nuclear_Neyenhuis","text":"KRb_Nuclear_Neyenhuis = NuclearParameters([0.45, -1.308], [-24.1e-6, 420.1e-6], -2030.4e-6)\n\nNuclearParameters with experimental values from Neyenhuis et al., PRL 109, 230403 (2012)\n\n\n\n\n\n","category":"constant"},{"location":"api/#MoleculeSpectrum.KRb_Nuclear_Ospelkaus","page":"API Documentation","title":"MoleculeSpectrum.KRb_Nuclear_Ospelkaus","text":"KRb_Nuclear_Ospelkaus = NuclearParameters([0.45, -1.41], [-24.1e-6, 420.1e-6], -2030.4e-6)\n\nNuclearParameters with experimental values from Ospelkaus et al., PRL 104, 030402 (2010)\n\n\n\n\n\n","category":"constant"},{"location":"api/#Vectors-and-Tensors","page":"API Documentation","title":"Vectors and Tensors","text":"","category":"section"},{"location":"api/#Spherical-vectors","page":"API Documentation","title":"Spherical vectors","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"SphericalVector\r\nVectorX\r\nVectorY\r\nVectorZ","category":"page"},{"location":"api/#MoleculeSpectrum.SphericalVector","page":"API Documentation","title":"MoleculeSpectrum.SphericalVector","text":"SphericalVector(magnitude, θ, φ)\n\nConstruct a vector with magnitude, polar angle θ, and azimuthal angle φ.\n\nRepresents an external field vector in spherical coordinates used to construct ExternalFields. Currently, SphericalVectors may be negated but no other mathematical operations are implemented.\n\nVectors along x, y, or z can be quickly constructed using VectorX, VectorY, and VectorZ, respectively.\n\nSee also SphericalUnitVector, ExternalFields.\n\n\n\n\n\n","category":"type"},{"location":"api/#MoleculeSpectrum.VectorX","page":"API Documentation","title":"MoleculeSpectrum.VectorX","text":"VectorX(magnitude)\n\nConstruct a SphericalVector with magnitude along x.\n\nExamples\n\njulia> VectorX(5.0)\nSphericalVector(5.0, 1.5707963267948966, 0.0)\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.VectorY","page":"API Documentation","title":"MoleculeSpectrum.VectorY","text":"VectorY(magnitude)\n\nConstruct a SphericalVector with magnitude along y.\n\nExamples\n\njulia> VectorY(2.0)\nSphericalVector(2.0, 1.5707963267948966, 1.5707963267948966)\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.VectorZ","page":"API Documentation","title":"MoleculeSpectrum.VectorZ","text":"VectorZ(magnitude)\n\nConstruct a SphericalVector with magnitude along z.\n\nExamples\n\njulia> VectorZ(10.0)\nSphericalVector(10.0, 0.0, 0.0)\n\n\n\n\n\n","category":"function"},{"location":"api/#Unit-vectors","page":"API Documentation","title":"Unit vectors","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"SphericalUnitVector\r\nUnitVectorX\r\nUnitVectorY\r\nUnitVectorZ","category":"page"},{"location":"api/#MoleculeSpectrum.SphericalUnitVector","page":"API Documentation","title":"MoleculeSpectrum.SphericalUnitVector","text":"SphericalUnitVector(magnitude, θ, φ)\nSphericalUnitVector(v::SphericalVector)\n\nConstruct a unit vector with polar angle θ, and azimuthal angle φ.\n\nRepresents the direction of an external field vector in spherical coordinates. Currently, SphericalUnitVectors may be negated but no other mathematical operations are implemented.\n\nVectors along x, y, or z can be quickly constructed using UnitVectorX, UnitVectorY, and UnitVectorZ, respectively.\n\nSee also SphericalVector, find_transition_strengths, T⁽¹⁾, T⁽²⁾.\n\n\n\n\n\n","category":"type"},{"location":"api/#MoleculeSpectrum.UnitVectorX","page":"API Documentation","title":"MoleculeSpectrum.UnitVectorX","text":"UnitVectorX()\n\nConstruct a SphericalUnitVector along x.\n\nExamples\n\njulia> UnitVectorX()\nSphericalUnitVector(1.5707963267948966, 0.0)\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.UnitVectorY","page":"API Documentation","title":"MoleculeSpectrum.UnitVectorY","text":"UnitVectorY()\n\nConstruct a SphericalUnitVector along y.\n\nExamples\n\njulia> UnitVectorY()\nSphericalUnitVector(1.5707963267948966, 1.5707963267948966)\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.UnitVectorZ","page":"API Documentation","title":"MoleculeSpectrum.UnitVectorZ","text":"UnitVectorZ()\n\nConstruct a SphericalUnitVector along z.\n\nExamples\n\njulia> UnitVectorZ()\nSphericalUnitVector(0.0, 0.0)\n\n\n\n\n\n","category":"function"},{"location":"api/#Tensors","page":"API Documentation","title":"Tensors","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"T⁽¹⁾\r\nT⁽²⁾\r\nget_tensor_component\r\ntensor_dot","category":"page"},{"location":"api/#MoleculeSpectrum.T⁽¹⁾","page":"API Documentation","title":"MoleculeSpectrum.T⁽¹⁾","text":"T⁽¹⁾(v)\n\nConstruct the components of the rank 1 spherical tensor T¹(v).\n\nExamples\n\njulia> T⁽¹⁾(UnitVectorX())\n3-element StaticArrays.SVector{3, ComplexF64} with indices SOneTo(3):\n    0.7071067811865475 - 0.0im\n 6.123233995736766e-17 + 0.0im\n   -0.7071067811865475 - 0.0im\n\njulia> T⁽¹⁾(UnitVectorY())\n3-element StaticArrays.SVector{3, ComplexF64} with indices SOneTo(3):\n  4.329780281177466e-17 - 0.7071067811865475im\n  6.123233995736766e-17 + 0.0im\n -4.329780281177466e-17 - 0.7071067811865475im\n\njulia> T⁽¹⁾(UnitVectorZ())\n3-element StaticArrays.SVector{3, ComplexF64} with indices SOneTo(3):\n  0.0 - 0.0im\n  1.0 + 0.0im\n -0.0 - 0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.T⁽²⁾","page":"API Documentation","title":"MoleculeSpectrum.T⁽²⁾","text":"T⁽²⁾(v)\n\nConstruct the components of the rank 2 spherical tensor T²(v v).\n\nExamples\n\njulia> T⁽²⁾(UnitVectorX())\n5-element StaticArrays.SVector{5, ComplexF64} with indices SOneTo(5):\n                    0.5 - 0.0im\n  6.123233995736766e-17 - 0.0im\n    -0.4082482904638631 + 0.0im\n -6.123233995736766e-17 - 0.0im\n                    0.5 + 0.0im\n\njulia> T⁽²⁾(UnitVectorY())\n5-element StaticArrays.SVector{5, ComplexF64} with indices SOneTo(5):\n                   -0.5 - 6.123233995736766e-17im\n  3.749399456654644e-33 - 6.123233995736766e-17im\n    -0.4082482904638631 + 0.0im\n -3.749399456654644e-33 - 6.123233995736766e-17im\n                   -0.5 + 6.123233995736766e-17im\n\njulia> T⁽²⁾(UnitVectorZ())\n5-element StaticArrays.SVector{5, ComplexF64} with indices SOneTo(5):\n                0.0 - 0.0im\n                0.0 - 0.0im\n 0.8164965809277261 + 0.0im\n               -0.0 - 0.0im\n                0.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.get_tensor_component","page":"API Documentation","title":"MoleculeSpectrum.get_tensor_component","text":"get_tensor_component(p::Int, tensor)\n\n#TODO: Document what get_tensor_component does.\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.tensor_dot","page":"API Documentation","title":"MoleculeSpectrum.tensor_dot","text":"tensor_dot(a, b)\n\nContract two spherical tensors a and b.\n\n\n\n\n\n","category":"function"},{"location":"api/#States","page":"API Documentation","title":"States","text":"","category":"section"},{"location":"api/#Types","page":"API Documentation","title":"Types","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"State\r\nKRbState","category":"page"},{"location":"api/#MoleculeSpectrum.State","page":"API Documentation","title":"MoleculeSpectrum.State","text":"struct State\n    N::Int\n    mₙ::Int\n    I::SVector{2,HalfInt}\n    mᵢ::SVector{2,HalfInt}\nend\n\nRepresents a molecular state in the uncoupled basis.\n\n\n\n\n\n","category":"type"},{"location":"api/#MoleculeSpectrum.KRbState","page":"API Documentation","title":"MoleculeSpectrum.KRbState","text":"KRbState(N, mₙ, mK, mRb)\n\nCreates a basis state N m_n m_textK m_textRb for ^40textK^87textRb.\n\nThis is a wrapper around State to avoid having to specify the nuclear spins I_k each time.\n\nSee also State.\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions","page":"API Documentation","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"index_to_state\r\nstate_to_index\r\norder_by_overlap_with\r\nmax_overlap_with\r\nfind_closest_basis_state\r\ndecompose_to_basis_states","category":"page"},{"location":"api/#MoleculeSpectrum.index_to_state","page":"API Documentation","title":"MoleculeSpectrum.index_to_state","text":"index_to_state(i, I₁, I₂)\n\nReturns the State corresponding to the ith member of the basis.\n\nThe uncoupled basis N mₙ I₁ mᵢ₁ I₂ mᵢ₂ is ordered with the quantum numbers on the left changing the slowest.\n\nSee also State, state_to_index.\n\nExamples\n\njulia> s = index_to_state(1, 4, 3/2)\nState(0, 0, HalfIntegers.Half{Int64}[4, 3/2], HalfIntegers.Half{Int64}[-4, -3/2])\n\njulia> s = index_to_state(37, 4, 3/2)\nState(1, -1, HalfIntegers.Half{Int64}[4, 3/2], HalfIntegers.Half{Int64}[-4, -3/2])\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.state_to_index","page":"API Documentation","title":"MoleculeSpectrum.state_to_index","text":"state_to_index(s::State)\n\nReturns index of state s in the basis.\n\nThe uncoupled basis N mₙ I₁ mᵢ₁ I₂ mᵢ₂ is ordered with the quantum numbers on the left changing the slowest.\n\nSee also State, index_to_state.\n\nExamples\n\njulia> state_to_index(KRbState(1, 1, -4, 1/2))\n111\n\njulia> state_to_index(index_to_state(42, 4, 3/2))\n42\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.order_by_overlap_with","page":"API Documentation","title":"MoleculeSpectrum.order_by_overlap_with","text":"order_by_overlap_with(spectrum, target)\n\nOrders the list of eigenstates from spectrum by their wavefunction overlap with target.\n\nSee also calculate_spectrum, max_overlap_with.\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.max_overlap_with","page":"API Documentation","title":"MoleculeSpectrum.max_overlap_with","text":"max_overlap_with(spectrum, target)\n\nFind the eigenstate from spectrum with the most wavefunction overlap with target.\n\nReturns a tuple (overlap, index), where overlap is the wavefunction overlap with target and index is the position of the eigenstates in spectrum.\n\nSee also calculate_spectrum, order_by_overlap_with.\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.find_closest_basis_state","page":"API Documentation","title":"MoleculeSpectrum.find_closest_basis_state","text":"find_closest_basis_state(spectrum, index)\n\nFind the basis state with the most wavefunction overlap with the eigenstate from spectrum at index.\n\nThis method can be thought of as an inverse to max_overlap_with. \n\nSee also calculate_spectrum, max_overlap_with.\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.decompose_to_basis_states","page":"API Documentation","title":"MoleculeSpectrum.decompose_to_basis_states","text":"decompose_to_basis_states(spectrum::Spectrum, index::Int)\ndecompose_to_basis_states(spectrum::Spectrum, state::Vector{ComplexF64})\ndecompose_to_basis_states(state::Vector{ComplexF64}, I1, I2)\n\nDecompose the given state into basis states in order of decreasing weight.\n\nOutputs a Vector{Tuple{State, Float64}}, giving a list [(basis_state, weight)]. The first variant provides the decomposition of the member of spectrum.eigenstates at position index. The second and third variants provide the decomposition of the vector state. The third variant does not require spectrum and recomputes the basis set according to I1 and I2.\n\nSee also calculate_spectrum, max_overlap_with.\n\n\n\n\n\n","category":"function"},{"location":"api/#Fields","page":"API Documentation","title":"Fields","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"ExternalFields\r\nDEFAULT_FIELDS\r\nTEST_FIELDS","category":"page"},{"location":"api/#MoleculeSpectrum.ExternalFields","page":"API Documentation","title":"MoleculeSpectrum.ExternalFields","text":"ExternalFields(B::SphericalVector, E::SphericalVector, Optical::Vector{SphericalVector})\nExternalFields(B::Float64, E::Float64)\n\nExternal magnetic, electric, optical fields to use in constructing the Hamiltonian.\n\nIf B and E are provided as Float64s, then the fields are assumed to be along z. The Optical argument can also be left as an empty vector [].\n\nSee also calculate_spectrum, hamiltonian, SphericalVector.\n\nExamples\n\njulia> ExternalFields(VectorZ(545.9), VectorX(1020.0), [])\nExternalFields(SphericalVector(545.9, 0.0, 0.0), SphericalVector(1020.0, 1.5707963267948966, 0.0), SphericalVector[])\n\njulia> ExternalFields(545.9, 1020.0)\nExternalFields(SphericalVector(545.9, 0.0, 0.0), SphericalVector(1020.0, 0.0, 0.0), SphericalVector[])\n\njulia> ExternalFields(VectorZ(545.9), VectorX(1020.0), [VectorY(2300.), SphericalVector(2300., π/2, π/4)])\nExternalFields(SphericalVector(545.9, 0.0, 0.0), SphericalVector(1020.0, 1.5707963267948966, 0.0), SphericalVector[SphericalVector(2300.0, 1.5707963267948966, 1.5707963267948966), SphericalVector(2300.0, 1.5707963267948966, 0.7853981633974483)])\n\n\n\n\n\n","category":"type"},{"location":"api/#MoleculeSpectrum.DEFAULT_FIELDS","page":"API Documentation","title":"MoleculeSpectrum.DEFAULT_FIELDS","text":"DEFAULT_FIELDS = ExternalFields(545.9, 0.0)\n\nDefines an ExternalFields with a magnetic field of 545.9 G along the z axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/#MoleculeSpectrum.TEST_FIELDS","page":"API Documentation","title":"MoleculeSpectrum.TEST_FIELDS","text":"TEST_FIELDS = ExternalFields(\n    SphericalVector(545.9, π / 4, π / 4),\n    SphericalVector(1000.0, 3π / 4, 7π / 4),\n    [SphericalVector(2350.0, 0.0, 0.0)],\n)\n\nDefines an ExternalFields with a magnetic, electric, and optical fields for tests.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Hamiltonians","page":"API Documentation","title":"Hamiltonians","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"hamiltonian\r\nHamiltonianParts\r\nmake_hamiltonian_parts\r\nmake_krb_hamiltonian_parts","category":"page"},{"location":"api/#MoleculeSpectrum.hamiltonian","page":"API Documentation","title":"MoleculeSpectrum.hamiltonian","text":"hamiltonian(parts, external_fields)\n\nConstruct the full Hamiltonian including magnetic, electric, and optical fields.\n\nReturns a dense Hermitian matrix.\n\nThe field-independent building blocks in parts can be reused over calls to hamiltonian to avoid recalculating the matrix elements each time.\n\nSee also make_hamiltonian_parts, make_krb_hamiltonian_parts, ExternalFields.\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.HamiltonianParts","page":"API Documentation","title":"MoleculeSpectrum.HamiltonianParts","text":"struct HamiltonianParts\n    basis::Vector{State}\n    rotation::SparseHamiltonian\n    dipole::SVector{3, SparseHamiltonian}\n    dipole_relative::SVector{3, SparseHamiltonian} # used for transition strengths\n    hyperfine::SparseHamiltonian\n    zeeman::SVector{3, SparseHamiltonian}\n    ac_scalar::SparseHamiltonian\n    ac_tensor::SVector{5, SparseHamiltonian}\nend\n\nContains all parts of the Hamiltonian except external fields.\n\nZeeman, dc Stark, and ac Stark terms are stored as vectors of matrices that can be contracted with the appropriate external field tensors. This allows the full Hamiltonian to be re-constructed at various field values and orientations without recalculating all of the matrix elements.\n\nShould be created by make_hamiltonian_parts or make_krb_hamiltonian_parts. Used as an input to calculate_spectrum and hamiltonian.\n\nSee also make_hamiltonian_parts, make_krb_hamiltonian_parts.\n\n\n\n\n\n","category":"type"},{"location":"api/#MoleculeSpectrum.make_hamiltonian_parts","page":"API Documentation","title":"MoleculeSpectrum.make_hamiltonian_parts","text":"make_hamiltonian_parts(molecular_parameters, N_max)\n\nConstruct all parts of the Hamiltonian that do not depend on external fields.\n\nThe size of the basis is determined by molecular_parameters, which contains the nuclear spin quantum numbers molecular_parameters.I, and the rotational states 0:N_max to include.\n\nSee also make_krb_hamiltonian_parts.\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.make_krb_hamiltonian_parts","page":"API Documentation","title":"MoleculeSpectrum.make_krb_hamiltonian_parts","text":"make_krb_hamiltonian_parts(N_max)\n\nConstruct all parts of the ^40textK^87textRb Hamiltonian that do not depend on external fields.\n\nThe rotational states 0:N_max are included. This is a shortcut method that replaces make_hamiltonian_parts for KRb.\n\nSee also make_hamiltonian_parts.\n\n\n\n\n\n","category":"function"},{"location":"api/#Spectra-and-Analysis","page":"API Documentation","title":"Spectra and Analysis","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Spectrum\r\ncalculate_spectrum\r\nget_energy\r\nget_energy_difference\r\nfind_transition_strengths\r\nplot_transition_strengths\r\ncalculate_dipolar_interaction","category":"page"},{"location":"api/#MoleculeSpectrum.Spectrum","page":"API Documentation","title":"MoleculeSpectrum.Spectrum","text":"Spectrum(hamiltonian_parts, energies, eigenstates)\n\nRepresents a molecular spectrum, including eigenvalues and eigenstates, given HamiltonianParts and ExternalFields.\n\nCreated from calculate_spectrum. See decompose_to_basis_states and get_energyfor access to eigenstates and energies.\n\n\n\n\n\n","category":"type"},{"location":"api/#MoleculeSpectrum.calculate_spectrum","page":"API Documentation","title":"MoleculeSpectrum.calculate_spectrum","text":"calculate_spectrum(hamiltonian_parts, external_fields)\n\nCompute the energies and eigenstates under the external fields.\n\nTo avoid reconstructing the Hamiltonian each time, hamiltonian_parts can be reused over calls to calculate_spectrum. The output Spectrum object is used as an input for further analysis, for example in find_transition_strengths.\n\nSee also make_hamiltonian_parts, make_krb_hamiltonian_parts, Spectrum.\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.get_energy","page":"API Documentation","title":"MoleculeSpectrum.get_energy","text":"get_energy(spectrum, target)\n\nReturn the energy of the eigenstate with the most wavefunction overlap with target.\n\nSee also calculate_spectrum, max_overlap_with.\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.get_energy_difference","page":"API Documentation","title":"MoleculeSpectrum.get_energy_difference","text":"get_energy_difference(spectrum, g, e)\n\nReturn the difference in energy between the eigenstates from spectrum that have the most wavefunction overlap with g and e.\n\nThis method is used to calculate transition frequencies; g represents the ground state, and e the excited state.\n\nSee also calculate_spectrum, get_energy.\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.find_transition_strengths","page":"API Documentation","title":"MoleculeSpectrum.find_transition_strengths","text":"find_transition_strengths(spectrum::Spectrum, g::State, frequency_range; polarization::Union{Int, SphericalUnitVector, Nothing}=nothing)\n\nCompute electric dipole transitions out of g with energy between frequency_range[1] and frequency_range[2].\n\nThe output is a Vector of tuples (frequency, strength, closest_basis_state, eigenstate_index), produced in decreasing order of transition strength. The strength is the absolute value of the dipole matrix element, normalized by Dsqrt3 (the maximum transition dipole between N = 0 and N = 1). We use the absolute value of the matrix element, rather than its square, so the results are proportional to Rabi frequency Ω.\n\nThe polarization keyword argument can be used to choose a specific microwave polarization. This defaults to nothing, which returns the incoherent sum over σ-, π, and σ+. If polarization is an Int, then it is interpreted as the spherical component p = -1:1 of the dipole operator (p == -1 corresponds to σ- polarization). If polarization is a SphericalUnitVector, then the polarization is interpreted as linear along that axis.\n\nThere is a convenience method plot_transition_strengths that immediately produces a plot from the result.\n\nSee also plot_transition_strengths, make_hamiltonian_parts, make_krb_hamiltonian_parts, Spectrum.\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.plot_transition_strengths","page":"API Documentation","title":"MoleculeSpectrum.plot_transition_strengths","text":"plot_transition_strengths(spectrum::Spectrum, g::State, frequency_range; polarization::Union{Int, SphericalUnitVector, Nothing}=nothing)\n\nPlot the frequencies and strengths of electric dipole transitions out of g, with energy between frequency_range[1] and frequency_range[2].\n\nThe polarization keyword argument can be used to choose a specific microwave polarization. This defaults to nothing, which returns the incoherent sum over σ-, π, and σ+. If polarization is an Int, then it is interpreted as the spherical component p = -1:1 of the dipole operator (p == -1 corresponds to σ- polarization). If polarization is a SphericalUnitVector, then the polarization is interpreted as linear along that axis.\n\nThis method calls find_transition_strengths internally.\n\nSee also find_transition_strengths, make_hamiltonian_parts, make_krb_hamiltonian_parts, Spectrum.\n\n\n\n\n\n","category":"function"},{"location":"api/#MoleculeSpectrum.calculate_dipolar_interaction","page":"API Documentation","title":"MoleculeSpectrum.calculate_dipolar_interaction","text":"calculate_dipolar_interaction(spectrum::Spectrum, g::State, e::State; p::Int = 0)\ncalculate_dipolar_interaction(spectrum::Spectrum, g::Vector{ComplexF64}, e::Vector{ComplexF64}; p::Int = 0)\n\n#TODO: Document calculate_dipolar_interaction\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API Documentation","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"","category":"page"},{"location":"#MoleculeSpectrum.jl","page":"MoleculeSpectrum","title":"MoleculeSpectrum.jl","text":"","category":"section"},{"location":"","page":"MoleculeSpectrum","title":"MoleculeSpectrum","text":"Computes the energy levels of diatomic ^1 Sigma molecules in magnetic, electric, and optical fields.","category":"page"},{"location":"#Todo","page":"MoleculeSpectrum","title":"Todo","text":"","category":"section"},{"location":"","page":"MoleculeSpectrum","title":"MoleculeSpectrum","text":"[x] Add transition strengths\n[ ] Dump to file, and/or dataframes?\n[ ] Graphing\n[x] Improve code organization\n[ ] Documentation\n[ ] Make it build!\n[ ] Remove unnecessary types in function arguments (?)\n[ ] API ergonomics\n[x] ExternalFields\n[ ] Get dipole matrix elements\n[ ] More generally... inspect any matrix element?\n[ ] Make more calculate functions polymorphic over State, eigenstate index, etc\n[ ] ...\n[x] Switch to get_eigenstates function\n[x] Explicitly type fields of all structs\n[ ] Many more tests!!!","category":"page"}]
}
